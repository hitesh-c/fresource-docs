## Chapter 6: Deadlock Part 3 (Distributed Environment)

- Resources and processes are located on different machines. 

- In distributed environment, the deadlock avoidance algorithm is avoided. That is because the avoidance algorith depends on information in advance, which is difficult to produce or know in a distributed environment. The desirable algorithms to use in such environment are deadlock detection &recovery or deadlock prevention.

- A __central coordinator__ maintains information on the resources requested from processed in the distributed environment. This information can be sent periodically from the machine executing the processes. Or it can be sent after every process finishes execution. 


- Scenario for analysis:
```Pascal
// Machine 0 (R means resource and P means process)
Pa <-- Rs, Pa --> Rr, Rr --> Pb

// Machine 1
Pc --> Rs, Pc < -- Rt

// The global resource graph maintained by central coordinator
Pc --> Rs, Pc < -- Rt,Pa <-- Rs, Pa --> Rr, Rr --> Pb
```

- Currently there is no cycle, so there is no deadlock. If _Pb_ releases _Rr_ and requests _Rt_ from _Machine_1 , there is a possibility that there will be a false alert of deadlock, which is also called __False Deadlock__. This happens because the central coordinator got update from _Machine 1_ first before the release request of _Rr_ from _Machine 0_.  

- This can avoided using a __global clock__ that contains the __timestamp__ of the request and releases of resources. 
 
- Such approach is also called a __Centralized Deadlock Detection__.

- There is another type of deadlock detection mechanism called __Distributed Deadlock Detection__. 

- Distributed Deadlock Detection Scenario for Analysis:

```Pascal
// Machine 0
P0, P1, P2

// Machine 1
P3, P4, P5

// Machine 2
P6, P7, P8, P9

// processes requests can be represented as a direct edge between processes
// Example

// Machine 0
P0 --> P1 // Process P0 is waiting for a resource acquired by P1
P1 --> P2
P2 --> P3 // P3 is a process in Machine_1

// Machine 1
P3 --> P4
P3 --> P5
P4 --> P6 // P6 is a process in Machine 2
P5 --> P7 // P7 is a process in Machine 2

// Machine 2
P6 --> P8
P7 --> P9
P8 --> P0 // P0 is a process in Machine_0
```

- When a process requests a resource held by another process. There is message being generated by a process. The message contains three bits of information as follows:

```Pascal
// Structure of message; 
< Pi, Pj, Pk > //Pi is process blocked; Pj is current process; Pk is requested process 

// As P0 requests resources from P1, the following message is generated
P0: < 0, 0, 1 >

// P1 modifies message and sends out modified version
// P1 --> P2
P1: < 0, 1, 2 >

// P2 --> P3
P2: < 0, 2, 3 >

// P3 --> P4
P3: < 0, 3, 4 >

// P3 --> P5
P3: < 0, 3, 4 >

// P5 --> P7 
P5: < 0, 5, 7 >

// P7 --> P9
P7: < 0, 7, 9 >

// P4 --> P6 
P4: < 0, 4, 6 >

// P6 --> P8
P6: < 0, 6, 8 >

// P8 --> P0 
P8: < 0, 8, 0 >

// Here the system realizes that Pi and Pk are identical and that there is a cycle creating a deadlock state.

```

- One simple solution to break the deadlock is to have P0 commit suicide -- terminates itself.

- Given that another process _P6_ is blocked, the message generated by _P6_ will be < 6, 6, 8 >. There will a situation where _P6_ will receive a message like < 6, 4, 6 > from _P4_. In such cases both _P0_ and _P6_ will need to be terminated. 

- In the scenario above, to avoid the termination of the two processes, an additional information can be inserted into the message before sending it out. the additional information contains the list of processes through which the message has passed. Now, the process that gets terminated is the last highest message, which in this case is process _P8_. Moreover, _P6_, when blocked, will also receive a message similar to _P0_. This ensures that the process to be killed is _P8_ instead of the two processes. The disadvantage is that more information has to be circulated before making a decision.

- Deadlock Prevention scenario: In this mechanism, a timestamp is assigned to each process. This timestamp is used to decide whether a resource requested by a process is granted or the process needs to wait. The following shows some of the criteria using this timestamp

```Pascal
// Given two processes with the following relationship
// Relationship: Pi is requesting resource allocated to Pj
Pi -- > Pj

Ti = 20 // execution time of process Pi
Tj = 10

// checks
If Ti > Tj then Pi waits
If Ti <= Tj then Pi is terminated 
```
